;; Q1
;; 数値のリストの要素をすべて 2 倍する関数 `double-list' を定義せよ。
;; ex. (double-list '(1 2 3 4 5)) => (2 4 6 8 10)

;; Q2
;; 数値のリストの要素をすべて 3 倍する関数 `triple-list' を定義せよ。
;; ex. (triple-list '(1 2 3 4 5)) => (3 6 9 12 15)

;; Q3
;; 数値のリストの要素をすべて二乗する関数 `square-list' を定義せよ。
;; ex. (square-list '(1 2 3 4 5)) => (1 4 9 16 25)

;; Q4
;; 数値のリストの要素すべてに 1 を加算する関数 `add1-list' を定義せよ。
;; (add1-list '(1 2 3 4 5)) => (2 3 4 5 6)

;; Q5
;; `mapcar' を使い、 Q1 ~ Q4 の問題を再定義せよ。
;; 必要ならば補助関数を定義せよ。

;; Q6
;; 数値のリストから偶数のみを抜き出す関数 `filter-even' を定義せよ。
;; ex. (filter-even '(1 2 3 4 5)) => '(2 4)
;; Hint: 偶数かどうかの判定には `evenp' を用いよ。
;;       (evenp 11) => nil
;;       (evenp 12) => t

;; Q7
;; 数値のリストから奇数のみを抜き出す関数 `filter-odd' を定義せよ。
;; ex. (filter-odd '(1 2 3 4 5)) => '(1 3 5)
;; Hint: 奇数かどうかの判定には `oddp' を用いよ。

;; Q8
;; 数値とシンボルからなるリストからシンボルのみを抜き出す関数 `filter-symbol' を定義せよ。
;; ex. (filter-symbol '(1 l 2 i 3 s 4 p 5)) => (L I S P)
;; Hint: シンボルかどうかの判定には `symbolp' を用いよ。

;; Q9
;; リストから 3 の倍数のみを抜き出す関数 `filter-triplet' を定義せよ。
;; ex. (filter-triplet '(0 1 3 6 10 15 21 28 36 45)) => 3 6 15 21 36 45
;; Hint: 除算のあまりは `rem' で求めよ。
;;       (rem 3 2) => 1

;; Q10
;; `remove-if-not' を使い、 Q6 ~ Q9 の問題を再定義せよ。
;; 必要ならば補助関数を定義せよ。

;; Q00 (Optional)
;; `remove-if-not' を使い、次の難読文字列からアルファベットのみを抜き出せ。
;; アルファベットかどうかの判定には both-case-p を用いよ。
;; 暇ならまず自分で探し、いかにプログラムで楽ができるかを体感せよ。
;; "*!!!h$!%*^$@a%@c!%!%k%@$!%t$@%!^@&^$^h^*@a$#&^t^%#l@%%!@i^!$s@&%$^p^@!#&%*e@##!$x&%$p*@$!r^!!%e*%#%^*s&$s*%^%&*i$$#o$&&n#"

;; Q11
;; 引数 start から end までの数値のリストを返す関数 `range' を定義せよ。
;; ex. (range 1 5) => (1 2 3 4 5)

;; Q12
;; 階乗を求める関数 `fact' を定義せよ。
;; (fact 5) => 120
;; 階乗の定義は以下の通り:
;; 0! = 1
;; 1! = 1
;; n! = n * (n-1)!

;; Q13
;; リストの総和を求める関数 `sum' を定義せよ。
;; 空リストの総和は 0 とする。

;; Q14
;; リストの積を求める関数 `product' を定義せよ。
;; 空リストの積は 1 とする。

;; Q15
;; 10 万以下の数のうち 3829 で割り切れる最大の数を求めよ。
;; 関数を定義しても、式のみでも、どちらでもよい。
;; Hint: `range', `remove-if-not', `reverse', `car' を組み合わせよ。
;; 出典:「すごいHaskellたのしく学ぼう！」

;; Q16
;; 1 から 151 までの奇数の平方数のうち、 10000 より小さい数の総和を求めよ。
;; 関数を定義しても、式のみでも、どちらでもよい。
;; Hint: `range', `mapcar', `remove-if-not' を組み合わせよ。
;;       平方数 (累乗) を求めるには `expt' 関数を用いよ。
;;       ex. (expt 100 2) => 10000
;; 出典:「すごいHaskellたのしく学ぼう！」

;; Q17
;; 引数 n のコラッツ数列を求める関数 `collatz' を定義せよ。
;; コラッツ数の定義は以下の通り:
;;   * 任意の自然数から開始する
;;   * 数が 1 ならば終了
;;   * 数が偶数なら 2 で割る
;;   * 数が奇数なら 3 倍して 1 を足す
;;   * 新しい値でアルゴリズムを繰り返す。
;; Hint: まずは手で計算して、アルゴリズムを体で覚えること。
;; ex. (collatz 10) => (10 5 16 8 4 2 1)
;; 出典:「すごいHaskellたのしく学ぼう！」

;; Q18
;; 1 から 100 までの数のうち、長さ 15 以上のコラッツ数列になる数値はいくつあるかを求めよ。
;; 必要ならば補助関数を定義せよ。
;; Hint: `range', `mapcar', `remove-if-not' を組み合わせよ。
;;       リストの長さを返す関数 `length' を活用せよ。
;; 出典:「すごいHaskellたのしく学ぼう！」

;; Q19
;; リストの要素を逆順にする関数 `my-reverse' を定義せよ。

;; Q20
;; Q13, Q14 および Q19 を `reduce' を使って再定義せよ。

;; Q21
;; Q1 ~ Q4, および Q9 を `flet' を使って再定義せよ。

;; Q22
;; Q1 ~ Q4, および Q9 を `lambda' を使って再定義せよ。

;; Q23
;; Q11 で定義した `range' の第二引数に巨大な数を渡し、スタックオーバーフローが発生することを確かめよ。
;; また、これを解決するために末尾再帰を使って再定義せよ。

;; Q24
;; Q12 も同様に、深い探索によってスタックオーバーフローが発生することを確かめよ。
;; また、これを解決するために末尾再帰を使って再定義せよ。

;; Q25
;; 数値 n までのフィボナッチ数列を返す関数 `fib' を定義せよ。
;; フィボナッチ数列の定義は以下の通り:
;; fib 0 = 0
;; fib 1 = 1
;; fib n = fib (n-2) + fib (n-1)

;; Q26
;; Q25 の `fib' を n=30 として呼び出し、何秒かかったかを計測せよ。
;; 処理時間を計測するには、特殊フォーム `time' を使う。
;; また、数値を 31, 32 と増やしていき、時間とプロセッササイクルの増大を確認せよ。
;; ex. (time (fib 30))
;; Warn: 大きな数を渡すと処理が戻ってこなくなるため、必要に応じて SLIME を再起動せよ。

;; Q27
;; Q25 の `fib' をメモワイズし、 `memoized-fib' として高速化を図れ。
;; また (memoized-fib 100) が一瞬で値を返すことを確認せよ。
